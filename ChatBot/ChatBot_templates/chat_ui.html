<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Chatbot Du Lịch</title>
<link rel="stylesheet" href="{{ url_for('chat_bot.static', filename='css/sidebar.css') }}">
<link rel="stylesheet" href="{{url_for('chat_bot.static', filename= 'css/style.css')}}" >
</head>

<body>

        <!-- Toggle Button -->
    <button id="sidebar-toggle" onclick="toggleSidebar()"> ☰ </button>

         <!-- SIDEBAR -->
        <div id="sidebar-wrapper" class="hidden">
            <div id="sidebar"></div>
        </div>

        <!-- MAIN CONTENT -->
    <div class="main-content">
        <h1>Trợ lý Du Lịch</h1>

        <div class="chat-container">
            <div class="chat-box" id="chatBox">
                <div id="loadingMsg">Đang tải cuộc trò chuyện cũ...</div>
            </div>

            <div class="input-area">
                <input id="userInput" placeholder="Hỏi gì đó về du lịch đi..." autocomplete="off">
                <button onclick="sendMessage()">Gửi ➤</button>
            </div>
        </div>
    </div>

    <script>
        const chatBox = document.getElementById('chatBox');
        const userInput = document.getElementById('userInput');
        const loadingMsg = document.getElementById('loadingMsg');

        // Hàm vẽ tin nhắn lên màn hình
       function appendMessage(text, sender) {
          // const chatBox = document.getElementById("chat-box");

          const isAtBottom = chatBox.scrollTop + chatBox.clientHeight >= chatBox.scrollHeight - 5;

          const msgContainer = document.createElement("div");
          msgContainer.className = sender === "user" ? "user-container" : "bot-container";

          const bubble = document.createElement("div");
          bubble.className = `message ${sender}`;
          bubble.textContent = text;

          msgContainer.appendChild(bubble);
          chatBox.appendChild(msgContainer);

           // Chỉ scroll xuống khi user đang ở cuối
          if (isAtBottom) {
              chatBox.scrollTop = chatBox.scrollHeight;
          }

          return bubble;  // trả về để SSE append tiếp
        }


        async function loadHistory() {
            try {
                const res = await fetch('/api/history');
                const data = await res.json();

                if (loadingMsg) loadingMsg.style.display = 'none';

                if (Array.isArray(data)) {
                    data.forEach(msg => {
                        appendMessage(msg.user_message, 'user');
                        appendMessage(msg.system_response, 'bot');
                    });
                }
            } catch (err) {
                console.error("Lỗi tải lịch sử:", err);
                if (loadingMsg) loadingMsg.innerText = "Chưa có lịch sử chat nào.";
            }
        }

        // Gửi tin nhắn mới 
        // tốc độ gõ (ký tự / giây)
    const charsPerSecond = 60; // đổi nhỏ hơn để chậm lại, lớn hơn để nhanh hơn

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function animateAppend(bubble, text) {
      // thêm từng ký tự với interval dựa trên charsPerSecond
      if (!text) return;
      const delay = 1000 / Math.max(1, charsPerSecond);
      for (let i = 0; i < text.length; i++) {
        bubble.textContent += text[i];
        // cuộn xuống cuối nếu cần
        if (chatBox) chatBox.scrollTop = chatBox.scrollHeight;
        await sleep(delay);
      }
    }

    async function sendMessage() {
      const message = userInput.value.trim();
      if (!message) return;

      // Hiện tin nhắn user
      appendMessage(message, 'user');
      userInput.value = '';

      // Tạo bubble rỗng cho bot và giữ reference
      const botBubble = appendMessage('', 'bot');

      try {
        const response = await fetch('/api/stream', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message })
        });

        if (!response.ok || !response.body) {
          botBubble.textContent = '⚠️ Lỗi kết nối server.';
          return;
        }

        const reader = response.body.getReader();
        const textDecoder  = new TextDecoder();
        let buffer = "";

        let done = false;
        let pendingAnimate = Promise.resolve(); // chuỗi các animation để giữ thứ tự

        while (!done) {
          const { value, done: streamDone } = await reader.read();
          done = streamDone;
          if (!value) continue;

           buffer += textDecoder.decode(value, { stream: true });
            
               // SSE event kết thúc bằng \n\n
            let parts = buffer.split(/\n\n/);

            // giữ lại phần cuối chưa hoàn chỉnh
            buffer = parts.pop() || "";

            for (let part of parts) {
                if (!part.trim()) continue;

              // Bỏ tiền tố "data: "
            const match = part.match(/^data:\s*(.*)$/i);
            if (!match) continue;

            const jsonStr = match[1].trim();
              // nếu backend gửi token đặc biệt [DONE]
              if (jsonStr  === '[DONE]') {
                // chờ tất cả animation hiện tại hoàn thành rồi kết thúc
                await pendingAnimate;
                return;
              }

                let parsed;
                try {
                parsed = JSON.parse(jsonStr);
                } catch(e) {
                console.error("Lỗi parse SSE chunk", e);
                continue;
                }

                if (parsed.type === "text") {
              // nếu có text thực, đẩy vào hàng animation để vẫn giữ thứ tự
              // (nếu 1 chunk lớn, sẽ animate từng ký tự liên tục)
              pendingAnimate = pendingAnimate.then(() => animateAppend(botBubble, parsed.data));
                } else if (parsed.type === "places") {
                    // cập nhật sidebar
                    renderSidebar(parsed.data);
                }
            
          }
        }

    // chờ animation cuối cùng xong
    await pendingAnimate;

  } catch (err) {
    console.error(err);
    botBubble.textContent = '⚠️ Mất kết nối server!';
  }
}


        // Nhấn Enter để gửi
        userInput.addEventListener('keypress', function (e) {
            if (e.key === 'Enter') sendMessage();
        });

        // Tự động tải lịch sử khi mở trang
        window.onload = loadHistory;
    </script>

    <!-- JS -->
  <script src="{{ url_for('chat_bot.static', filename='js/sidebar.js') }}"></script>
  <script src="{{ url_for('chat_bot.static', filename='js/chat.js') }}"></script>
</body>
</html>
